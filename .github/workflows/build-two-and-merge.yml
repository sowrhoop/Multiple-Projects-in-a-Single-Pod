name: Build Service A & B, then Merge

permissions:
  contents: read
  packages: write
  id-token: write

on:
  workflow_dispatch:
    inputs:
      service_a_repo:
        description: "GitHub repo for Service A (owner/repo)"
        required: true
      service_a_ref:
        description: "Git ref for Service A (branch/tag/sha)"
        default: "main"
        required: true
      service_a_dockerfile:
        description: "Path to Dockerfile in Service A repo"
        default: "Dockerfile"
        required: true
      service_b_repo:
        description: "GitHub repo for Service B (owner/repo)"
        required: true
      service_b_ref:
        description: "Git ref for Service B (branch/tag/sha)"
        default: "main"
        required: true
      service_b_dockerfile:
        description: "Path to Dockerfile in Service B repo"
        default: "Dockerfile"
        required: true
      use_gpu_base:
        description: "Use GPU base for merged image (CUDA)"
        type: boolean
        default: false
  repository_dispatch:
    types: [merge-two, project-updated]

concurrency:
  group: build-merge-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-and-merge:
    runs-on: ubuntu-latest
    env:
      OWNER: ${{ github.repository_owner }}
    steps:
      - name: Resolve parameters (dispatch or manual)
        id: params
        shell: bash
        env:
          IN_SA_REPO: ${{ inputs.service_a_repo }}
          IN_SA_REF: ${{ inputs.service_a_ref }}
          IN_SA_DF: ${{ inputs.service_a_dockerfile }}
          IN_SB_REPO: ${{ inputs.service_b_repo }}
          IN_SB_REF: ${{ inputs.service_b_ref }}
          IN_SB_DF: ${{ inputs.service_b_dockerfile }}
          IN_GPU: ${{ inputs.use_gpu_base }}
          PL_SA_REPO: ${{ github.event.client_payload.service_a_repo }}
          PL_SA_REF: ${{ github.event.client_payload.service_a_ref }}
          PL_SA_DF: ${{ github.event.client_payload.service_a_dockerfile }}
          PL_SB_REPO: ${{ github.event.client_payload.service_b_repo }}
          PL_SB_REF: ${{ github.event.client_payload.service_b_ref }}
          PL_SB_DF: ${{ github.event.client_payload.service_b_dockerfile }}
          PL_GPU: ${{ github.event.client_payload.use_gpu_base }}
          OWNER: ${{ github.repository_owner }}
        run: |
          SA_REPO=${IN_SA_REPO:-${PL_SA_REPO:-"${OWNER}/project-1"}}
          SA_REF=${IN_SA_REF:-${PL_SA_REF:-main}}
          SA_DF=${IN_SA_DF:-${PL_SA_DF:-Dockerfile}}
          SB_REPO=${IN_SB_REPO:-${PL_SB_REPO:-"${OWNER}/project-2"}}
          SB_REF=${IN_SB_REF:-${PL_SB_REF:-main}}
          SB_DF=${IN_SB_DF:-${PL_SB_DF:-Dockerfile}}
          GPU_FLAG=${IN_GPU:-${PL_GPU:-false}}

          echo "service_a_repo=${SA_REPO}" >> "$GITHUB_OUTPUT"
          echo "service_a_ref=${SA_REF}" >> "$GITHUB_OUTPUT"
          echo "service_a_dockerfile=${SA_DF}" >> "$GITHUB_OUTPUT"
          echo "service_b_repo=${SB_REPO}" >> "$GITHUB_OUTPUT"
          echo "service_b_ref=${SB_REF}" >> "$GITHUB_OUTPUT"
          echo "service_b_dockerfile=${SB_DF}" >> "$GITHUB_OUTPUT"
          echo "use_gpu_base=${GPU_FLAG}" >> "$GITHUB_OUTPUT"
      - name: Checkout orchestrator repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Checkout Service A
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.params.outputs.service_a_repo }}
          ref: ${{ steps.params.outputs.service_a_ref }}
          token: ${{ secrets.GH_PAT != '' && secrets.GH_PAT || github.token }}
          path: external/service-a

      - name: Checkout Service B
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.params.outputs.service_b_repo }}
          ref: ${{ steps.params.outputs.service_b_ref }}
          token: ${{ secrets.GH_PAT != '' && secrets.GH_PAT || github.token }}
          path: external/service-b

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Compute tags
        id: vars
        run: |
          echo "tag_sha=${GITHUB_SHA}" >> "$GITHUB_OUTPUT"
          echo "owner_lc=${OWNER,,}" >> "$GITHUB_OUTPUT"

      - name: Build & push Project 1 image
        uses: docker/build-push-action@v6
        with:
          context: external/service-a
          file: external/service-a/${{ inputs.service_a_dockerfile }}
          push: true
          platforms: linux/amd64
          tags: |
            ghcr.io/${{ steps.vars.outputs.owner_lc }}/project-1:latest
            ghcr.io/${{ steps.vars.outputs.owner_lc }}/project-1:${{ steps.vars.outputs.tag_sha }}

      - name: Build & push Project 2 image
        uses: docker/build-push-action@v6
        with:
          context: external/service-b
          file: external/service-b/${{ inputs.service_b_dockerfile }}
          push: true
          platforms: linux/amd64
          tags: |
            ghcr.io/${{ steps.vars.outputs.owner_lc }}/project-2:latest
            ghcr.io/${{ steps.vars.outputs.owner_lc }}/project-2:${{ steps.vars.outputs.tag_sha }}

      - name: Build & push merged Supervisor image
        id: merge
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ${{ steps.params.outputs.use_gpu_base == 'true' && 'Dockerfile.supervisor.from-images.gpu' || 'Dockerfile.supervisor.from-images' }}
          push: true
          platforms: linux/amd64
          build-args: |
            SERVICE_A_IMAGE=ghcr.io/${{ steps.vars.outputs.owner_lc }}/project-1:${{ steps.vars.outputs.tag_sha }}
            SERVICE_B_IMAGE=ghcr.io/${{ steps.vars.outputs.owner_lc }}/project-2:${{ steps.vars.outputs.tag_sha }}
          tags: |
            ghcr.io/${{ steps.vars.outputs.owner_lc }}/supervisor-image-combination:latest
            ghcr.io/${{ steps.vars.outputs.owner_lc }}/supervisor-image-combination:${{ steps.vars.outputs.tag_sha }}

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3

      - name: Sign merged image (keyless)
        env:
          COSIGN_EXPERIMENTAL: "1"
          IMAGE_NAME: ghcr.io/${{ steps.vars.outputs.owner_lc }}/supervisor-image-combination
        run: |
          cosign sign --yes ${IMAGE_NAME}@${{ steps.merge.outputs.digest }}

      - name: Trivy scan (merged image)
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: ghcr.io/${{ steps.vars.outputs.owner_lc }}/supervisor-image-combination@${{ steps.merge.outputs.digest }}
          format: sarif
          output: trivy-results.sarif
          vuln-type: 'os,library'
          severity: 'CRITICAL,HIGH'
          ignore-unfixed: true
          exit-code: '0'

      - name: Upload Trivy SARIF
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy-results.sarif